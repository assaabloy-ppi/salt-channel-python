# -*- coding: utf-8 -*-

import unittest
from unittest import TestCase

import saltchannel.v2.exceptions
from saltchannel.exceptions import BadPeer

import saltchannel.v2.packets as packets

from saltchannel.util.crypto_test_data import CryptoTestData

class BaseTest(TestCase):
    def __init__(self, *args, **kwargs):
        TestCase.__init__(self, *args, **kwargs)

    def setUp(self):
        pass

    def tearDown(self):
        pass


class TestM1(BaseTest):

    def test_M1_properties(self):
        m1 = packets.M1Packet()

        m1.ClientEncKey = CryptoTestData.aEnc.pub
        self.assertEqual(m1.ClientEncKey, CryptoTestData.aEnc.pub)

        m1.data.Header.ServerSigKeyIncluded = 1
        m1.data.Header.TicketIncluded = 1
        m1.create_opt_fields()  # always configure all opt-related Header fields before calling create_opt_fields()
        m1.ServerSigKey = CryptoTestData.bSig.pub
        self.assertEqual(m1.ServerSigKey, CryptoTestData.bSig.pub)
        m1.Ticket = CryptoTestData.random32a
        self.assertEqual(m1.Ticket, CryptoTestData.random32a)

    # case data generated by https://github.com/assaabloy-ppi/salt-channel/blob/master/src/saltchannel/dev/ExamplePacketDump.java
    # Date: 2017-10-26
    def test_M1_dumps_case1(self):
        # M1 CASE: 1 -> time:  0x7badf00d, serverSigKey: null, ticket: null, ticketRequested: false
        # sizeof(M1): 42, M1: "5343763201000df0ad7b8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a"
        m1_strdump = '5343763201000df0ad7b8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a'
        m1_dump = bytes.fromhex(m1_strdump)

        m1 = packets.M1Packet()
        m1.data.Time = 0x7badf00d
        m1.ClientEncKey = CryptoTestData.aEnc.pub

        self.assertEqual(m1.size, 42)
        self.assertEqual(bytes(m1), m1_dump)

        # do the same, but init via constructor

        # creating M1Packet from bytes
        m1b = packets.M1Packet()
        m1b.from_bytes(m1_dump)

        self.assertEqual(m1b.size, 42)
        self.assertEqual(bytes(m1b), m1_dump)

        self.assertEqual(packets.PacketType.TYPE_M1.value, m1.data.Header.PacketType, m1b.data.Header.PacketType)
        self.assertEqual(m1.data.Time, m1b.data.Time)
        self.assertEqual(m1.ClientEncKey, m1b.ClientEncKey)

    # case data generated by https://github.com/assaabloy-ppi/salt-channel/blob/master/src/saltchannel/dev/ExamplePacketDump.java
    # Date: 2017-10-26
    def test_M1_dumps_case2(self):
        # M1 CASE: 2 -> time:  0x7badf00d, serverSigKey: +, ticket: null, ticketRequested: false
        # sizeof(M1): 74, M1: '5343763201010df0ad7b8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a07e28d4ee32bfdc4b07d41c92193c0c25ee6b3094c6296f373413b373d36168b'
        m1_strdump = '5343763201010df0ad7b8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a07e28d4ee32bfdc4b07d41c92193c0c25ee6b3094c6296f373413b373d36168b'
        m1_dump = bytes.fromhex(m1_strdump)

        m1 = packets.M1Packet()
        m1.data.Header.ServerSigKeyIncluded = 1
        m1.data.Time = 0x7badf00d
        m1.ClientEncKey = CryptoTestData.aEnc.pub
        m1.create_opt_fields()  # always configure all opt-related Header fields before calling create_opt_fields()
        m1.ServerSigKey = CryptoTestData.bSig.pub

        self.assertEqual(m1.size, 74)
        self.assertEqual(bytes(m1), m1_dump)

        # creating M1Packet from bytes
        m1b = packets.M1Packet()
        m1b.from_bytes(m1_dump)

        self.assertEqual(m1b.size, 74)
        self.assertEqual(bytes(m1b), m1_dump)

        self.assertEqual(packets.PacketType.TYPE_M1.value, m1.data.Header.PacketType, m1b.data.Header.PacketType)
        self.assertEqual(m1.data.Header.ServerSigKeyIncluded, m1b.data.Header.ServerSigKeyIncluded)
        self.assertEqual(m1.data.Time, m1b.data.Time)
        self.assertEqual(m1.ClientEncKey, m1b.ClientEncKey)
        self.assertEqual(m1.ServerSigKey, m1b.ServerSigKey)

class TestM2(BaseTest):

    def test_M2_properties(self):
        m2 = packets.M2Packet()

        m2.ServerEncKey = CryptoTestData.aEnc.pub
        self.assertEqual(m2.ServerEncKey, CryptoTestData.aEnc.pub)

    # case data generated by https://github.com/assaabloy-ppi/salt-channel/blob/master/src/saltchannel/dev/ExamplePacketDump.java
    # Date: 2017-10-27
    def test_M2_dumps_case1(self):
        # M2 CASE: 1 -> time:  0x7badf00d, ServerEncKey: +, noSuchServer/LastFlag: false
        # sizeof(M2): 38, M2: '02000df0ad7bde9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f'
        m2_strdump = '02000df0ad7bde9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f'
        m2_dump = bytes.fromhex(m2_strdump)

        m2 = packets.M2Packet()
        m2.data.Header.NoSuchServer = 0
        m2.data.Time = 0x7badf00d
        m2.ServerEncKey = CryptoTestData.bEnc.pub

        self.assertEqual(m2.size, 38)
        self.assertEqual(bytes(m2), m2_dump)

        # creating M2Packet from bytes
        m2b = packets.M2Packet()
        m2b.from_bytes(m2_dump)

        self.assertEqual(m2b.size, 38)
        self.assertEqual(bytes(m2b), m2_dump)

        self.assertEqual(packets.PacketType.TYPE_M2.value, m2.data.Header.PacketType, m2b.data.Header.PacketType)
        self.assertEqual(m2.data.Header.NoSuchServer, m2b.data.Header.NoSuchServer)
        self.assertEqual(m2.data.Time, m2b.data.Time)
        self.assertEqual(m2.ServerEncKey, m2b.ServerEncKey)

   # case data generated by https://github.com/assaabloy-ppi/salt-channel/blob/master/src/saltchannel/dev/ExamplePacketDump.java
    # Date: 2017-10-27
    def test_M2_dumps_noSuchServerLastFlag(self):
        # M2 CASE: 2 -> time:  0x7badf00d, ServerEncKey: +, noSuchServer/LastFlag: true
        # sizeof(M2): 38, M2: '02810df0ad7b0000000000000000000000000000000000000000000000000000000000000000'
        m2_strdump = '02810df0ad7b0000000000000000000000000000000000000000000000000000000000000000'
        m2_dump = bytes.fromhex(m2_strdump)

        m2 = packets.M2Packet()
        m2.data.Header.NoSuchServer = 1
        m2.data.Time = 0x7badf00d

        self.assertEqual(m2.size, 38)
        self.assertEqual(bytes(m2), m2_dump)

        # creating M2Packet from bytes
        m2b = packets.M2Packet()
        m2b.from_bytes(m2_dump)

        self.assertEqual(m2b.size, 38)
        self.assertEqual(bytes(m2b), m2_dump)

        self.assertEqual(packets.PacketType.TYPE_M2.value, m2.data.Header.PacketType, m2b.data.Header.PacketType)
        self.assertEqual(m2.data.Header.NoSuchServer, m2b.data.Header.NoSuchServer)
        self.assertEqual(m2.data.Time, m2b.data.Time)
        self.assertEqual(m2.ServerEncKey, m2b.ServerEncKey)

        self.assertEqual(m2b.data.Header.LastFlag, 1)  # LastFlag is implied

class TestM3(BaseTest):

    def test_M3_properties(self):
        m3 = packets.M3Packet()

        m3.ServerSigKey = CryptoTestData.bSig.pub
        self.assertEqual(m3.ServerSigKey, CryptoTestData.bSig.pub)

        m3.Signature1 = CryptoTestData.random64a
        self.assertEqual(m3.Signature1, CryptoTestData.random64a)

    def test_M3_dumps_case1(self):
        # M3 CASE: 1 -> time:  0x7badf00d, ServerEncKey: bSig.pub
        # sizeof(M3): 102, M3: "03000df0ad7b07e28d4ee32bfdc4b07d41c92193c0c25ee6b3094c6296f373413b373d36168bbe3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6"
        m3_strdump = '03000df0ad7b07e28d4ee32bfdc4b07d41c92193c0c25ee6b3094c6296f373413b373d36168bbe3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        m3_dump = bytes.fromhex(m3_strdump)

        m3 = packets.M3Packet()
        m3.data.Time = 0x7badf00d
        m3.ServerSigKey = CryptoTestData.bSig.pub
        m3.Signature1 = CryptoTestData.random64a

        self.assertEqual(m3.size, 102)
        self.assertEqual(bytes(m3), m3_dump)

        # creating M3Packet from bytes
        m3b = packets.M3Packet()
        m3b.from_bytes(m3_dump)

        self.assertEqual(m3b.size, 102)
        self.assertEqual(bytes(m3b), m3_dump)

        self.assertEqual(packets.PacketType.TYPE_M3.value, m3.data.Header.PacketType, m3b.data.Header.PacketType)
        self.assertEqual(m3.data.Time, m3b.data.Time)
        self.assertEqual(m3.ServerSigKey, m3b.ServerSigKey)
        self.assertEqual(m3.Signature1, m3b.Signature1)


class TestM4(BaseTest):

    def test_M4_properties(self):
        m4 = packets.M4Packet()

        m4.ClientSigKey = CryptoTestData.aSig.pub
        self.assertEqual(m4.ClientSigKey, CryptoTestData.aSig.pub)

        m4.Signature2 = CryptoTestData.random64a
        self.assertEqual(m4.Signature2, CryptoTestData.random64a)

    def test_M4_dumps_case1(self):
        # M4 CASE: 1 -> time:  0x7badf00d, ClientSigKey: aSig.pub
        # sizeof(M4): 102, M4: '04000df0ad7b5529ce8ccf68c0b8ac19d437ab0f5b32723782608e93c6264f184ba152c2357bbe3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        m4_strdump = '04000df0ad7b5529ce8ccf68c0b8ac19d437ab0f5b32723782608e93c6264f184ba152c2357bbe3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        m4_dump = bytes.fromhex(m4_strdump)

        m4 = packets.M4Packet()
        m4.data.Time = 0x7badf00d
        m4.ClientSigKey = CryptoTestData.aSig.pub
        m4.Signature2 = CryptoTestData.random64a

        self.assertEqual(m4.size, 102)
        self.assertEqual(bytes(m4), m4_dump)

        # creating M4Packet from bytes
        m4b = packets.M4Packet()
        m4b.from_bytes(m4_dump)

        self.assertEqual(m4b.size, 102)
        self.assertEqual(bytes(m4b), m4_dump)

        self.assertEqual(packets.PacketType.TYPE_M4.value, m4.data.Header.PacketType, m4b.data.Header.PacketType)
        self.assertEqual(m4.data.Time, m4b.data.Time)
        self.assertEqual(m4.ClientSigKey, m4b.ClientSigKey)
        self.assertEqual(m4.Signature2, m4b.Signature2)


class TestEncryptedPacket(BaseTest):

    def test_EncryptedPacket_properties(self):
        e = packets.EncryptedPacket()

        e.Body = CryptoTestData.random64a
        self.assertEqual(e.Body, CryptoTestData.random64a)

    def test_EncryptedPacket_from_bytes(self):
        e = packets.EncryptedPacket(src_buf=bytes.fromhex('0600112233445566778899112233445566778899aabbccddeeff'))
        self.assertEqual(e.Body, bytes.fromhex('112233445566778899112233445566778899aabbccddeeff'))

    def test_EncryptedPacket_dumps_case1(self):
        # EncryptedPacket CASE: 1 -> LastFlag: false
        #  sizeof(EP): 66, EP: '0600be3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        ep_strdump = '0600be3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        ep_dump = bytes.fromhex(ep_strdump)

        ep = packets.EncryptedPacket()
        ep.Body = bytes.fromhex('be3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6')
        ep.data.Header.LastFlag = 0

        self.assertEqual(ep.size, 66)
        self.assertEqual(bytes(ep), ep_dump)

        # creating EncryptedPacket from bytes
        epb = packets.EncryptedPacket()
        epb.from_bytes(ep_dump)

        self.assertEqual(epb.size, 66)
        self.assertEqual(bytes(epb), ep_dump)

        self.assertEqual(packets.PacketType.TYPE_ENCRYPTED_PACKET.value, ep.data.Header.PacketType, epb.data.Header.PacketType)
        self.assertEqual(ep.Body, epb.Body)
        self.assertEqual(ep.data.Header.LastFlag, epb.data.Header.LastFlag)

    def test_EncryptedPacket_dumps_case2(self):
        # EncryptedPacket CASE: 2 -> LastFlag: true
        # sizeof(EP): 66, EP: '0680be3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        ep_strdump = '0680be3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6'
        ep_dump = bytes.fromhex(ep_strdump)

        ep = packets.EncryptedPacket()
        ep.Body = bytes.fromhex('be3552a308cd05afd2943030a5a582259875d00ab313a7f6d8a8fc6bf3af4732491cbc6d62351b396c8121a077e739f7764992f30be24a9b25ddedc3d68388c6')
        ep.data.Header.LastFlag = 1

        self.assertEqual(ep.size, 66)
        self.assertEqual(bytes(ep), ep_dump)

        # creating EncryptedPacket from bytes
        epb = packets.EncryptedPacket()
        epb.from_bytes(ep_dump)

        self.assertEqual(epb.size, 66)
        self.assertEqual(bytes(epb), ep_dump)

        self.assertEqual(packets.PacketType.TYPE_ENCRYPTED_PACKET.value, ep.data.Header.PacketType, epb.data.Header.PacketType)
        self.assertEqual(ep.Body, epb.Body)
        self.assertEqual(ep.data.Header.LastFlag, epb.data.Header.LastFlag)


class TestAppPacket(BaseTest):

    def test_AppPacket_properties(self):
        app = packets.AppPacket()

        app.Data = CryptoTestData.random64a
        self.assertEqual(app.Data, CryptoTestData.random64a)

    def test_AppPacket_from_bytes(self):
        ap = packets.AppPacket(src_buf=bytes.fromhex('050000000000112233445566778899112233445566778899aabbccddeeff'))
        self.assertEqual(ap.Data, bytes.fromhex('112233445566778899112233445566778899aabbccddeeff'))

    def test_AppPacket_invalid_input(self):
        app = packets.AppPacket()
        with self.assertRaises(BadPeer) as cm:
            app.from_bytes(bytes(1))

        with self.assertRaises(BadPeer) as cm:
            app.from_bytes(bytes(5))


class TestMultiAppPacket(BaseTest):

    def test_MultiAppPacket_properties1(self):
        mapp = packets.MultiAppPacket()

        msg0 = b'12'
        msg1 = b'3456'
        msg2 = b''
        msg3 = b'\x00'
        msg4 = b'7'
        messages = [msg0, msg1, msg2, msg3, msg4]

        mapp.data.Count = len(messages)
        mapp.create_opt_fields(msgs=messages)

        self.assertEqual(mapp.opt.Message, messages)
        self.assertEqual(mapp.opt.Message[1], msg1)

    def test_MultiAppPacket_serialization(self):
        mapp = packets.MultiAppPacket()

        msg0 = b'12'
        msg1 = b'3456'
        msg2 = b''
        msg3 = b'\x00'
        msg4 = b'7'
        messages = [msg0, msg1, msg2, msg3, msg4]

        mapp.data.Count = len(messages)
        mapp.create_opt_fields(msgs=messages)

        self.assertEqual(mapp.opt.Message, messages)

        # serialization/deserialization basic test
        mappb = packets.MultiAppPacket()
        mappb.from_bytes(bytes(mapp))

        self.assertEqual(mappb.opt.Message, messages)

    def test_MultiAppPacket_dumps_case1(self):
        # MultiApp CASE: 1
        # sizeof(MultiApp): 15, MultiApp: '0b000df0ad7b020001000402000505'
        mp_strdump = '0b000df0ad7b020001000402000505'
        mp_dump = bytes.fromhex(mp_strdump)

        messages = [b'\x04', b'\x05\x05']

        mp = packets.MultiAppPacket()
        mp.data.Time = 0x7badf00d
        mp.data.Count = len(messages)
        mp.create_opt_fields(msgs=messages)

        self.assertEqual(mp.size, 15)
        self.assertEqual(bytes(mp), mp_dump)

        # creating MultiAppPacket from bytes
        mpb = packets.MultiAppPacket()
        mpb.from_bytes(mp_dump)

        self.assertEqual(mpb.size, 15)
        self.assertEqual(bytes(mpb), mp_dump)

        self.assertEqual(packets.PacketType.TYPE_MULTIAPP_PACKET.value, mp.data.Header.PacketType, mpb.data.Header.PacketType)
        self.assertEqual(mpb.data.Time, 0x7badf00d)
        self.assertEqual(mpb.data.Count, 2)
        self.assertEqual(len(mpb.opt.Message), mpb.data.Count)
        self.assertEqual(mpb.opt.Message[0], b'\x04')
        self.assertEqual(mpb.opt.Message[1], b'\x05\x05')


if __name__ == '__main__':
    unittest.main()